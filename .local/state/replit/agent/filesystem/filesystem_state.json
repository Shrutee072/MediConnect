{"file_contents":{"replit.md":{"content":"# Medical API Project\n\n## Overview\n\nThis is a FastAPI-based Medical Practice Management system designed for doctor registration, authentication, and profile management. The application provides a RESTful API for medical professionals to register, verify their accounts through OTP, manage their profiles, and access master data for medical specialities and sub-specialities.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Framework\n- **FastAPI**: Modern, fast web framework for building APIs with automatic API documentation\n- **SQLAlchemy**: ORM for database operations with declarative base models\n- **Alembic**: Database migration management (configured but migrations not visible in current structure)\n\n### Authentication & Security\n- **JWT (JSON Web Tokens)**: Stateless authentication using python-jose library\n- **Password Hashing**: Secure password storage using bcrypt via passlib\n- **Bearer Token Authentication**: HTTP Bearer scheme for API endpoint protection\n- **OTP Verification**: Email-based one-time password system for account verification\n\n### Database Design\n- **PostgreSQL**: Primary database using psycopg2-binary driver\n- **Connection Pooling**: Configured with pool_pre_ping and pool_recycle for reliability\n- **Three main entities**:\n  - **Doctor**: Core user entity with profile information and medical credentials\n  - **MedicalSpeciality**: Master data for medical specializations\n  - **MedicalSubSpeciality**: Hierarchical sub-specializations linked to main specialities\n\n### API Structure\n- **Modular Router Design**: Separate routers for different functional areas\n  - `/auth`: Registration, login, and OTP verification endpoints\n  - `/doctor`: Doctor profile management (get/update profile)\n  - `/master`: Master data endpoints for specialities and sub-specialities\n- **Pydantic Schemas**: Request/response validation and serialization\n- **Dependency Injection**: Database sessions and authentication handled via FastAPI dependencies\n\n### Configuration Management\n- **Environment-based Settings**: Database URL, JWT secrets, and other sensitive data via environment variables\n- **Centralized Configuration**: Settings class with validation and defaults\n- **Security Validation**: Enforced requirements for critical environment variables\n\n### Data Validation & Serialization\n- **Pydantic Models**: Type-safe request/response handling with email validation\n- **Separation of Concerns**: Distinct schemas for create, update, and response operations\n- **Automatic Documentation**: OpenAPI/Swagger documentation generation\n\n## External Dependencies\n\n### Core Framework Dependencies\n- **FastAPI**: Web framework with automatic API documentation\n- **Uvicorn**: ASGI server for running the FastAPI application\n- **SQLAlchemy**: Database ORM for PostgreSQL operations\n- **Pydantic**: Data validation and serialization with email support\n\n### Security & Authentication\n- **python-jose[cryptography]**: JWT token creation and verification\n- **passlib[bcrypt]**: Password hashing and verification\n\n### Database Integration\n- **PostgreSQL**: Primary database system (requires DATABASE_URL environment variable)\n- **psycopg2-binary**: PostgreSQL adapter for Python\n- **Alembic**: Database migration management\n\n### Email & Communication\n- **OTP System**: Custom implementation for email verification (email sending functionality referenced but not implemented in visible code)\n\n### Environment Requirements\n- **DATABASE_URL**: PostgreSQL connection string\n- **SESSION_SECRET**: JWT signing secret key\n- **DEBUG**: Optional debug mode flag","size_bytes":3625},"app/__init__.py":{"content":"","size_bytes":0},"app/config.py":{"content":"import os\nfrom typing import Optional\n\nclass Settings:\n    # Database settings\n    DATABASE_URL: Optional[str] = os.environ.get(\"DATABASE_URL\")\n    \n    # JWT settings\n    SECRET_KEY: str = os.environ.get(\"SESSION_SECRET\")\n    if not SECRET_KEY:\n        raise ValueError(\"SESSION_SECRET environment variable is required for secure JWT operations\")\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    \n    # OTP settings\n    OTP_EXPIRE_MINUTES: int = 5\n    OTP_LENGTH: int = 6\n    \n    # Application settings\n    PROJECT_NAME: str = \"Medical API\"\n    VERSION: str = \"1.0.0\"\n    DEBUG: bool = os.environ.get(\"DEBUG\", \"false\").lower() == \"true\"\n\nsettings = Settings()","size_bytes":687},"app/db.py":{"content":"import os\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\n\nDATABASE_URL = os.environ.get('DATABASE_URL')\nif not DATABASE_URL:\n    raise ValueError(\"DATABASE_URL environment variable is required\")\nengine = create_engine(DATABASE_URL, pool_pre_ping=True, pool_recycle=300)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()","size_bytes":516},"app/main.py":{"content":"from fastapi import FastAPI\nfrom app.routers import auth, doctor, master, social, posts\nfrom app.config import settings\nfrom app.utils.scheduler import start_scheduler, stop_scheduler\nimport atexit\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    description=\"FastAPI with PostgreSQL integration for Medical Practice Management\",\n    version=settings.VERSION\n)\n\n# Include routers\napp.include_router(auth.router)\napp.include_router(doctor.router)\napp.include_router(master.router)\napp.include_router(social.router)\napp.include_router(posts.router)\n\n# Start the post scheduler\nstart_scheduler()\n\n# Register cleanup function\natexit.register(stop_scheduler)\n\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"ok\", \"message\": \"Medical API is running\"}\n\n@app.get(\"/\")\nasync def root():\n    return {\n        \"message\": \"Welcome to Medical API\",\n        \"version\": settings.VERSION,\n        \"endpoints\": {\n            \"authentication\": \"/auth\",\n            \"doctor_profile\": \"/doctor\",\n            \"master_data\": \"/master\",\n            \"social_accounts\": \"/social\",\n            \"posts\": \"/posts\",\n            \"health_check\": \"/health\",\n            \"documentation\": \"/docs\"\n        }\n    }","size_bytes":1197},"app/models/__init__.py":{"content":"","size_bytes":0},"app/models/models.py":{"content":"from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, Boolean, Enum, func\nfrom sqlalchemy.orm import relationship\nimport enum\nfrom app.db import Base\n\n\nclass VerificationStatus(enum.Enum):\n    PENDING = \"pending\"\n    VERIFIED = \"verified\"\n    REJECTED = \"rejected\"\n\n\nclass MedicalSpeciality(Base):\n    __tablename__ = \"medical_specialities\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), unique=True, nullable=False, index=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    sub_specialities = relationship(\"MedicalSubSpeciality\", back_populates=\"speciality\")\n    doctors = relationship(\"Doctor\", back_populates=\"speciality\")\n\n\nclass MedicalSubSpeciality(Base):\n    __tablename__ = \"medical_sub_specialities\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    speciality_id = Column(Integer, ForeignKey(\"medical_specialities.id\"), nullable=False)\n    name = Column(String(100), nullable=False, index=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    speciality = relationship(\"MedicalSpeciality\", back_populates=\"sub_specialities\")\n    doctors = relationship(\"Doctor\", back_populates=\"sub_speciality\")\n\n\nclass Doctor(Base):\n    __tablename__ = \"doctors\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    full_name = Column(String(200), nullable=False, index=True)\n    email = Column(String(255), unique=True, nullable=False, index=True)\n    hashed_password = Column(String(255), nullable=False)\n    phone_number = Column(String(20))  # WhatsApp contact number\n    clinic_name = Column(String(200))\n    clinic_address = Column(Text)\n    speciality_id = Column(Integer, ForeignKey(\"medical_specialities.id\"))\n    sub_speciality_id = Column(Integer, ForeignKey(\"medical_sub_specialities.id\"))\n    years_of_experience = Column(Integer)\n    qualification = Column(String(500))  # Professional qualifications\n    medical_institute = Column(String(300))\n    awards = Column(Text)\n    medical_council_regd_no = Column(String(50), unique=True)\n    profile_photo = Column(String(500))  # URL or file path\n    professional_bio = Column(Text)  # Professional bio/description\n    is_verified = Column(Enum(VerificationStatus), default=VerificationStatus.PENDING)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    speciality = relationship(\"MedicalSpeciality\", back_populates=\"doctors\")\n    sub_speciality = relationship(\"MedicalSubSpeciality\", back_populates=\"doctors\")\n    social_accounts = relationship(\"SocialAccount\", back_populates=\"doctor\")\n    posts = relationship(\"Post\", back_populates=\"doctor\")\n\n\nclass OTPVerification(Base):\n    __tablename__ = \"otp_verifications\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String(255), nullable=False, index=True)\n    otp_code = Column(String(6), nullable=False)\n    purpose = Column(String(20), nullable=False)  # registration, login, reset_password\n    is_used = Column(Boolean, default=False)\n    expires_at = Column(DateTime(timezone=True), nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())","size_bytes":3483},"app/models/post.py":{"content":"from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Text, Enum\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom app.db import Base\nimport enum\n\n\nclass PostStatus(enum.Enum):\n    SCHEDULED = \"scheduled\"\n    PUBLISHED = \"published\"\n    FAILED = \"failed\"\n\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    doctor_id = Column(Integer, ForeignKey(\"doctors.id\"), nullable=False)\n    social_account_id = Column(Integer, ForeignKey(\"social_accounts.id\"), nullable=False)\n    platform = Column(String(50), nullable=False)\n    content = Column(Text, nullable=False)\n    media_url = Column(String(500), nullable=True)\n    scheduled_at = Column(DateTime(timezone=True), nullable=False)\n    status = Column(Enum(PostStatus), default=PostStatus.SCHEDULED)\n    error_message = Column(Text, nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    doctor = relationship(\"Doctor\", back_populates=\"posts\")\n    social_account = relationship(\"SocialAccount\", back_populates=\"posts\")","size_bytes":1132},"app/models/social_account.py":{"content":"from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Text\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom app.db import Base\n\n\nclass SocialAccount(Base):\n    __tablename__ = \"social_accounts\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    doctor_id = Column(Integer, ForeignKey(\"doctors.id\"), nullable=False)\n    platform = Column(String(50), nullable=False)  # facebook, instagram, linkedin, twitter, youtube, reddit, quora\n    page_id = Column(String(255), nullable=True)  # For pages/organizations\n    access_token = Column(Text, nullable=False)\n    refresh_token = Column(Text, nullable=True)\n    token_expires_at = Column(DateTime(timezone=True), nullable=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    doctor = relationship(\"Doctor\", back_populates=\"social_accounts\")\n    posts = relationship(\"Post\", back_populates=\"social_account\")","size_bytes":966},"app/routers/__init__.py":{"content":"","size_bytes":0},"app/routers/auth.py":{"content":"from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nfrom datetime import timedelta\nfrom typing import Annotated\n\nfrom app.db import get_db\nfrom app.models.models import Doctor, VerificationStatus\nfrom app.schemas.auth import (\n    DoctorRegisterRequest, OTPVerificationRequest, LoginRequest, \n    TokenResponse, OTPResponse\n)\nfrom app.utils.jwt import (\n    verify_password, get_password_hash, create_access_token, \n    get_current_user_id\n)\nfrom app.utils.otp import create_otp, verify_otp, send_otp_email\nfrom app.config import settings\n\nrouter = APIRouter(prefix=\"/auth\", tags=[\"Authentication\"])\nsecurity = HTTPBearer()\n\n\ndef get_current_doctor(\n    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get the current authenticated doctor.\"\"\"\n    token = credentials.credentials\n    user_id = get_current_user_id(token)\n    \n    if user_id is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    doctor = db.query(Doctor).filter(Doctor.id == user_id).first()\n    if doctor is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Doctor not found\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    return doctor\n\n\n@router.post(\"/register\", response_model=OTPResponse)\nasync def register_doctor(\n    doctor_data: DoctorRegisterRequest,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Register a new doctor and send OTP for verification.\"\"\"\n    # Check if doctor already exists\n    existing_doctor = db.query(Doctor).filter(Doctor.email == doctor_data.email).first()\n    if existing_doctor:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Doctor with this email already exists\"\n        )\n    \n    # Check if medical council registration number is already used\n    if doctor_data.medical_council_regd_no:\n        existing_reg = db.query(Doctor).filter(\n            Doctor.medical_council_regd_no == doctor_data.medical_council_regd_no\n        ).first()\n        if existing_reg:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Medical council registration number already exists\"\n            )\n    \n    # Create doctor record\n    hashed_password = get_password_hash(doctor_data.password)\n    new_doctor = Doctor(\n        full_name=doctor_data.full_name,\n        email=doctor_data.email,\n        hashed_password=hashed_password,\n        phone_number=doctor_data.phone_number,\n        clinic_name=doctor_data.clinic_name,\n        clinic_address=doctor_data.clinic_address,\n        speciality_id=doctor_data.speciality_id,\n        sub_speciality_id=doctor_data.sub_speciality_id,\n        years_of_experience=doctor_data.years_of_experience,\n        qualification=doctor_data.qualification,\n        medical_institute=doctor_data.medical_institute,\n        awards=doctor_data.awards,\n        medical_council_regd_no=doctor_data.medical_council_regd_no,\n        profile_photo=doctor_data.profile_photo,\n        professional_bio=doctor_data.professional_bio,\n        is_verified=VerificationStatus.PENDING\n    )\n    \n    db.add(new_doctor)\n    db.commit()\n    \n    # Generate and send OTP\n    otp_code, expires_at = create_otp(db, doctor_data.email, \"registration\")\n    send_otp_email(doctor_data.email, otp_code, \"registration\")\n    \n    return OTPResponse(\n        message=\"Registration successful. Please verify your email with the OTP sent to your email address.\",\n        email=doctor_data.email,\n        expires_in_minutes=settings.OTP_EXPIRE_MINUTES\n    )\n\n\n@router.post(\"/verify-registration\", response_model=TokenResponse)\nasync def verify_registration(\n    verification_data: OTPVerificationRequest,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Verify OTP and complete registration.\"\"\"\n    # Verify OTP\n    if not verify_otp(db, verification_data.email, verification_data.otp_code, \"registration\"):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid or expired OTP\"\n        )\n    \n    # Get the doctor\n    doctor = db.query(Doctor).filter(Doctor.email == verification_data.email).first()\n    if not doctor:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Doctor not found\"\n        )\n    \n    # Mark doctor as verified\n    db.query(Doctor).filter(Doctor.id == doctor.id).update({\n        \"is_verified\": VerificationStatus.VERIFIED\n    })\n    db.commit()\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": str(doctor.id)}, expires_delta=access_token_expires\n    )\n    \n    return TokenResponse(\n        access_token=access_token,\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60\n    )\n\n\n@router.post(\"/login\", response_model=OTPResponse)\nasync def login_request(\n    login_data: LoginRequest,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Request login and send OTP.\"\"\"\n    # Check if doctor exists and password is correct\n    doctor = db.query(Doctor).filter(Doctor.email == login_data.email).first()\n    if not doctor:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\"\n        )\n    \n    if not verify_password(login_data.password, str(doctor.hashed_password)):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\"\n        )\n    \n    # Check if doctor is verified\n    if doctor.is_verified != VerificationStatus.VERIFIED:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Account not verified. Please complete email verification first.\"\n        )\n    \n    # Generate and send OTP\n    otp_code, expires_at = create_otp(db, login_data.email, \"login\")\n    send_otp_email(login_data.email, otp_code, \"login\")\n    \n    return OTPResponse(\n        message=\"OTP sent to your email address. Please verify to complete login.\",\n        email=login_data.email,\n        expires_in_minutes=settings.OTP_EXPIRE_MINUTES\n    )\n\n\n@router.post(\"/verify-login\", response_model=TokenResponse)\nasync def verify_login(\n    verification_data: OTPVerificationRequest,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Verify OTP and complete login.\"\"\"\n    # Verify OTP\n    if not verify_otp(db, verification_data.email, verification_data.otp_code, \"login\"):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid or expired OTP\"\n        )\n    \n    # Get the doctor\n    doctor = db.query(Doctor).filter(Doctor.email == verification_data.email).first()\n    if not doctor:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Doctor not found\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": str(doctor.id)}, expires_delta=access_token_expires\n    )\n    \n    return TokenResponse(\n        access_token=access_token,\n        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60\n    )","size_bytes":7585},"app/routers/doctor.py":{"content":"from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom typing import Annotated\n\nfrom app.db import get_db\nfrom app.models.models import Doctor, MedicalSpeciality, MedicalSubSpeciality\nfrom app.schemas.doctor import DoctorResponse, DoctorUpdate\nfrom app.routers.auth import get_current_doctor\nfrom app.utils.profile import calculate_profile_completeness, get_profile_completeness_tips\n\nrouter = APIRouter(prefix=\"/doctor\", tags=[\"Doctor Profile\"])\n\n\n@router.get(\"/profile\", response_model=DoctorResponse)\nasync def get_doctor_profile(\n    current_doctor: Annotated[Doctor, Depends(get_current_doctor)],\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get the logged-in doctor's profile.\"\"\"\n    # Get speciality and sub-speciality names\n    speciality_name = None\n    sub_speciality_name = None\n    \n    if current_doctor.speciality_id is not None:\n        speciality = db.query(MedicalSpeciality).filter(\n            MedicalSpeciality.id == current_doctor.speciality_id\n        ).first()\n        if speciality:\n            speciality_name = speciality.name\n    \n    if current_doctor.sub_speciality_id is not None:\n        sub_speciality = db.query(MedicalSubSpeciality).filter(\n            MedicalSubSpeciality.id == current_doctor.sub_speciality_id\n        ).first()\n        if sub_speciality:\n            sub_speciality_name = sub_speciality.name\n    \n    # Calculate profile completeness\n    completeness_percentage = calculate_profile_completeness(current_doctor)\n    completeness_tips = get_profile_completeness_tips(current_doctor)\n    \n    # Create response with additional fields\n    doctor_dict = DoctorResponse.model_validate(current_doctor).model_dump()\n    doctor_dict['speciality_name'] = speciality_name\n    doctor_dict['sub_speciality_name'] = sub_speciality_name\n    doctor_dict['completeness_percentage'] = completeness_percentage\n    doctor_dict['completeness_tips'] = completeness_tips if completeness_percentage < 100 else None\n    \n    return DoctorResponse(**doctor_dict)\n\n\n@router.put(\"/profile\", response_model=DoctorResponse)\nasync def update_doctor_profile(\n    profile_data: DoctorUpdate,\n    current_doctor: Annotated[Doctor, Depends(get_current_doctor)],\n    db: Session = Depends(get_db)\n):\n    \"\"\"Update the logged-in doctor's profile.\"\"\"\n    # Check if medical council registration number is already used by another doctor\n    if profile_data.medical_council_regd_no:\n        existing_reg = db.query(Doctor).filter(\n            Doctor.medical_council_regd_no == profile_data.medical_council_regd_no,\n            Doctor.id != current_doctor.id\n        ).first()\n        if existing_reg:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Medical council registration number already exists\"\n            )\n    \n    # Validate speciality and sub-speciality if provided\n    if profile_data.speciality_id:\n        speciality = db.query(MedicalSpeciality).filter(\n            MedicalSpeciality.id == profile_data.speciality_id\n        ).first()\n        if not speciality:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid speciality ID\"\n            )\n    \n    if profile_data.sub_speciality_id:\n        sub_speciality = db.query(MedicalSubSpeciality).filter(\n            MedicalSubSpeciality.id == profile_data.sub_speciality_id\n        ).first()\n        if not sub_speciality:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid sub-speciality ID\"\n            )\n        \n        # Check if sub-speciality belongs to the selected speciality\n        if profile_data.speciality_id and sub_speciality.speciality_id != profile_data.speciality_id:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Sub-speciality does not belong to the selected speciality\"\n            )\n    \n    # Update doctor profile\n    update_data = profile_data.model_dump(exclude_unset=True)\n    if update_data:\n        db.query(Doctor).filter(Doctor.id == current_doctor.id).update(update_data)\n        db.commit()\n        \n        # Refresh the doctor object\n        db.refresh(current_doctor)\n    \n    # Get updated profile with speciality names and completeness\n    return await get_doctor_profile(current_doctor, db)","size_bytes":4427},"app/routers/master.py":{"content":"from fastapi import APIRouter, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import Optional\n\nfrom app.db import get_db\nfrom app.models.models import MedicalSpeciality, MedicalSubSpeciality\nfrom app.schemas.master import (\n    SpecialitiesListResponse, SubSpecialitiesListResponse,\n    MedicalSpecialityResponse, MedicalSubSpecialityResponse\n)\n\nrouter = APIRouter(prefix=\"/master\", tags=[\"Master Data\"])\n\n\n@router.get(\"/specialities\", response_model=SpecialitiesListResponse)\nasync def get_specialities(\n    db: Session = Depends(get_db),\n    skip: int = Query(0, ge=0, description=\"Number of records to skip\"),\n    limit: int = Query(100, ge=1, le=500, description=\"Number of records to return\")\n):\n    \"\"\"Get list of all medical specialities.\"\"\"\n    specialities = db.query(MedicalSpeciality).offset(skip).limit(limit).all()\n    total = db.query(MedicalSpeciality).count()\n    \n    specialities_data = [\n        MedicalSpecialityResponse.model_validate(speciality) \n        for speciality in specialities\n    ]\n    \n    return SpecialitiesListResponse(\n        specialities=specialities_data,\n        total=total\n    )\n\n\n@router.get(\"/sub-specialities\", response_model=SubSpecialitiesListResponse)\nasync def get_sub_specialities(\n    db: Session = Depends(get_db),\n    speciality_id: Optional[int] = Query(None, description=\"Filter by speciality ID\"),\n    skip: int = Query(0, ge=0, description=\"Number of records to skip\"),\n    limit: int = Query(100, ge=1, le=500, description=\"Number of records to return\")\n):\n    \"\"\"Get list of medical sub-specialities, optionally filtered by speciality.\"\"\"\n    query = db.query(MedicalSubSpeciality)\n    \n    if speciality_id:\n        query = query.filter(MedicalSubSpeciality.speciality_id == speciality_id)\n    \n    sub_specialities = query.offset(skip).limit(limit).all()\n    total = query.count()\n    \n    # Prepare response data with speciality names\n    sub_specialities_data = []\n    for sub_speciality in sub_specialities:\n        sub_speciality_data = MedicalSubSpecialityResponse.model_validate(sub_speciality)\n        \n        # Get speciality name\n        if sub_speciality.speciality:\n            sub_speciality_data.speciality_name = sub_speciality.speciality.name\n        \n        sub_specialities_data.append(sub_speciality_data)\n    \n    return SubSpecialitiesListResponse(\n        sub_specialities=sub_specialities_data,\n        total=total,\n        speciality_id=speciality_id\n    )","size_bytes":2458},"app/routers/posts.py":{"content":"from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom datetime import datetime\nfrom app.db import get_db\nfrom app.models.models import Doctor\nfrom app.models.social_account import SocialAccount\nfrom app.models.post import Post, PostStatus\nfrom app.schemas.social import PostCreate, PostUpdate, PostResponse\nfrom app.utils.jwt import get_current_doctor\nimport logging\n\nrouter = APIRouter(prefix=\"/posts\", tags=[\"posts\"])\nlogger = logging.getLogger(__name__)\n\n\n@router.post(\"/\", response_model=PostResponse)\nasync def create_scheduled_post(\n    post_data: PostCreate,\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Create a scheduled post\"\"\"\n    # Verify the social account belongs to the current doctor\n    social_account = db.query(SocialAccount).filter(\n        SocialAccount.id == post_data.social_account_id,\n        SocialAccount.doctor_id == current_doctor.id\n    ).first()\n    \n    if not social_account:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Social account not found or not owned by current doctor\"\n        )\n    \n    # Check if scheduled time is in the future\n    if post_data.scheduled_at <= datetime.now():\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Scheduled time must be in the future\"\n        )\n    \n    # Create new post\n    new_post = Post(\n        doctor_id=current_doctor.id,\n        social_account_id=post_data.social_account_id,\n        platform=social_account.platform,\n        content=post_data.content,\n        media_url=post_data.media_url,\n        scheduled_at=post_data.scheduled_at,\n        status=PostStatus.SCHEDULED\n    )\n    \n    db.add(new_post)\n    db.commit()\n    db.refresh(new_post)\n    \n    logger.info(f\"Created scheduled post {new_post.id} for doctor {current_doctor.id} on {social_account.platform}\")\n    \n    return new_post\n\n\n@router.get(\"/\", response_model=List[PostResponse])\nasync def list_posts(\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"List all posts for the logged-in doctor\"\"\"\n    posts = db.query(Post).filter(\n        Post.doctor_id == current_doctor.id\n    ).order_by(Post.created_at.desc()).all()\n    \n    return posts\n\n\n@router.put(\"/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    post_id: int,\n    post_update: PostUpdate,\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Update a scheduled post (only if status is SCHEDULED)\"\"\"\n    post = db.query(Post).filter(\n        Post.id == post_id,\n        Post.doctor_id == current_doctor.id\n    ).first()\n    \n    if not post:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Post not found or not owned by current doctor\"\n        )\n    \n    if post.status != PostStatus.SCHEDULED:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Can only update scheduled posts\"\n        )\n    \n    # Update fields\n    update_data = post_update.dict(exclude_unset=True)\n    \n    # Validate scheduled_at if provided\n    if \"scheduled_at\" in update_data:\n        if update_data[\"scheduled_at\"] <= datetime.now():\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Scheduled time must be in the future\"\n            )\n    \n    for field, value in update_data.items():\n        setattr(post, field, value)\n    \n    db.commit()\n    db.refresh(post)\n    \n    logger.info(f\"Updated post {post_id} for doctor {current_doctor.id}\")\n    \n    return post\n\n\n@router.delete(\"/{post_id}\")\nasync def cancel_post(\n    post_id: int,\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Cancel a scheduled post\"\"\"\n    post = db.query(Post).filter(\n        Post.id == post_id,\n        Post.doctor_id == current_doctor.id\n    ).first()\n    \n    if not post:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Post not found or not owned by current doctor\"\n        )\n    \n    if post.status != PostStatus.SCHEDULED:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Can only cancel scheduled posts\"\n        )\n    \n    db.delete(post)\n    db.commit()\n    \n    logger.info(f\"Cancelled post {post_id} for doctor {current_doctor.id}\")\n    \n    return {\"message\": \"Post cancelled successfully\"}","size_bytes":4648},"app/routers/social.py":{"content":"from fastapi import APIRouter, Depends, HTTPException, status, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom app.db import get_db\nfrom app.models.models import Doctor\nfrom app.models.social_account import SocialAccount\nfrom app.schemas.social import SocialAccountResponse, OAuthUrlResponse\nfrom app.utils.jwt import get_current_doctor\nimport logging\n\nrouter = APIRouter(prefix=\"/social\", tags=[\"social\"])\nlogger = logging.getLogger(__name__)\n\n# Supported platforms\nSUPPORTED_PLATFORMS = [\"facebook\", \"instagram\", \"linkedin\", \"twitter\", \"youtube\", \"reddit\", \"quora\"]\n\n\n@router.get(\"/accounts\", response_model=List[SocialAccountResponse])\nasync def list_social_accounts(\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get all connected social accounts for the logged-in doctor\"\"\"\n    accounts = db.query(SocialAccount).filter(\n        SocialAccount.doctor_id == current_doctor.id\n    ).all()\n    return accounts\n\n\n@router.post(\"/connect/{platform}\", response_model=OAuthUrlResponse)\nasync def generate_oauth_url(\n    platform: str,\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Generate OAuth authorization URL for the specified platform\"\"\"\n    if platform not in SUPPORTED_PLATFORMS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Platform {platform} not supported. Supported platforms: {SUPPORTED_PLATFORMS}\"\n        )\n    \n    # For now, return a dummy URL - in production this would generate real OAuth URLs\n    authorization_url = f\"https://oauth.{platform}.com/authorize?client_id=dummy&redirect_uri=callback&scope=publish\"\n    \n    logger.info(f\"Generated OAuth URL for doctor {current_doctor.id} on platform {platform}\")\n    \n    return OAuthUrlResponse(authorization_url=authorization_url)\n\n\n@router.get(\"/callback/{platform}\")\nasync def oauth_callback(\n    platform: str,\n    code: str = Query(..., description=\"OAuth authorization code\"),\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Handle OAuth2 callback and save access token\"\"\"\n    if platform not in SUPPORTED_PLATFORMS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Platform {platform} not supported\"\n        )\n    \n    # Check if account already exists\n    existing_account = db.query(SocialAccount).filter(\n        SocialAccount.doctor_id == current_doctor.id,\n        SocialAccount.platform == platform\n    ).first()\n    \n    if existing_account:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Social account for {platform} already connected\"\n        )\n    \n    # For now, create dummy token - in production this would exchange code for real tokens\n    dummy_token = f\"dummy_access_token_{platform}_{current_doctor.id}\"\n    \n    # Create new social account\n    new_account = SocialAccount(\n        doctor_id=current_doctor.id,\n        platform=platform,\n        access_token=dummy_token,\n        refresh_token=None,\n        token_expires_at=None\n    )\n    \n    db.add(new_account)\n    db.commit()\n    db.refresh(new_account)\n    \n    logger.info(f\"Connected {platform} account for doctor {current_doctor.id}\")\n    \n    return {\"message\": f\"Successfully connected {platform} account\", \"account_id\": new_account.id}\n\n\n@router.delete(\"/accounts/{account_id}\")\nasync def disconnect_social_account(\n    account_id: int,\n    current_doctor: Doctor = Depends(get_current_doctor),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Disconnect a social media account\"\"\"\n    account = db.query(SocialAccount).filter(\n        SocialAccount.id == account_id,\n        SocialAccount.doctor_id == current_doctor.id\n    ).first()\n    \n    if not account:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Social account not found or not owned by current doctor\"\n        )\n    \n    platform = account.platform\n    db.delete(account)\n    db.commit()\n    \n    logger.info(f\"Disconnected {platform} account {account_id} for doctor {current_doctor.id}\")\n    \n    return {\"message\": f\"Successfully disconnected {platform} account\"}","size_bytes":4281},"app/schemas/__init__.py":{"content":"","size_bytes":0},"app/schemas/auth.py":{"content":"from pydantic import BaseModel, EmailStr\nfrom typing import Optional\n\n\nclass DoctorRegisterRequest(BaseModel):\n    full_name: str\n    email: EmailStr\n    password: str\n    phone_number: Optional[str] = None\n    clinic_name: Optional[str] = None\n    clinic_address: Optional[str] = None\n    speciality_id: Optional[int] = None\n    sub_speciality_id: Optional[int] = None\n    years_of_experience: Optional[int] = None\n    qualification: Optional[str] = None\n    medical_institute: Optional[str] = None\n    awards: Optional[str] = None\n    medical_council_regd_no: Optional[str] = None\n    profile_photo: Optional[str] = None\n    professional_bio: Optional[str] = None\n\n\nclass OTPVerificationRequest(BaseModel):\n    email: EmailStr\n    otp_code: str\n\n\nclass LoginRequest(BaseModel):\n    email: EmailStr\n    password: str\n\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n    expires_in: int\n\n\nclass OTPResponse(BaseModel):\n    message: str\n    email: str\n    expires_in_minutes: int","size_bytes":1016},"app/schemas/doctor.py":{"content":"from pydantic import BaseModel, EmailStr\nfrom typing import Optional, List\nfrom datetime import datetime\n\n\nclass DoctorBase(BaseModel):\n    full_name: str\n    email: EmailStr\n    phone_number: Optional[str] = None\n    clinic_name: Optional[str] = None\n    clinic_address: Optional[str] = None\n    speciality_id: Optional[int] = None\n    sub_speciality_id: Optional[int] = None\n    years_of_experience: Optional[int] = None\n    qualification: Optional[str] = None\n    medical_institute: Optional[str] = None\n    awards: Optional[str] = None\n    medical_council_regd_no: Optional[str] = None\n    profile_photo: Optional[str] = None\n    professional_bio: Optional[str] = None\n\n\nclass DoctorCreate(DoctorBase):\n    password: str\n\n\nclass DoctorUpdate(BaseModel):\n    full_name: Optional[str] = None\n    phone_number: Optional[str] = None\n    clinic_name: Optional[str] = None\n    clinic_address: Optional[str] = None\n    speciality_id: Optional[int] = None\n    sub_speciality_id: Optional[int] = None\n    years_of_experience: Optional[int] = None\n    qualification: Optional[str] = None\n    medical_institute: Optional[str] = None\n    awards: Optional[str] = None\n    medical_council_regd_no: Optional[str] = None\n    profile_photo: Optional[str] = None\n    professional_bio: Optional[str] = None\n\n\nclass DoctorResponse(DoctorBase):\n    id: int\n    is_verified: str\n    created_at: datetime\n    updated_at: Optional[datetime] = None\n    \n    # Related data\n    speciality_name: Optional[str] = None\n    sub_speciality_name: Optional[str] = None\n    \n    # Profile completeness\n    completeness_percentage: int\n    completeness_tips: Optional[List[str]] = None\n\n    class Config:\n        from_attributes = True","size_bytes":1704},"app/schemas/master.py":{"content":"from pydantic import BaseModel\nfrom typing import Optional, List\nfrom datetime import datetime\n\n\nclass MedicalSpecialityBase(BaseModel):\n    name: str\n\n\nclass MedicalSpecialityCreate(MedicalSpecialityBase):\n    pass\n\n\nclass MedicalSpecialityResponse(MedicalSpecialityBase):\n    id: int\n    created_at: datetime\n    updated_at: Optional[datetime] = None\n\n    class Config:\n        from_attributes = True\n\n\nclass MedicalSubSpecialityBase(BaseModel):\n    speciality_id: int\n    name: str\n\n\nclass MedicalSubSpecialityCreate(MedicalSubSpecialityBase):\n    pass\n\n\nclass MedicalSubSpecialityResponse(MedicalSubSpecialityBase):\n    id: int\n    created_at: datetime\n    updated_at: Optional[datetime] = None\n    speciality_name: Optional[str] = None\n\n    class Config:\n        from_attributes = True\n\n\nclass SpecialitiesListResponse(BaseModel):\n    specialities: List[MedicalSpecialityResponse]\n    total: int\n\n\nclass SubSpecialitiesListResponse(BaseModel):\n    sub_specialities: List[MedicalSubSpecialityResponse]\n    total: int\n    speciality_id: Optional[int] = None","size_bytes":1060},"app/schemas/social.py":{"content":"from pydantic import BaseModel\nfrom typing import Optional, List\nfrom datetime import datetime\nfrom app.models.post import PostStatus\n\n\nclass SocialAccountBase(BaseModel):\n    platform: str\n    page_id: Optional[str] = None\n\n\nclass SocialAccountCreate(SocialAccountBase):\n    access_token: str\n    refresh_token: Optional[str] = None\n    token_expires_at: Optional[datetime] = None\n\n\nclass SocialAccountResponse(SocialAccountBase):\n    id: int\n    doctor_id: int\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\nclass PostBase(BaseModel):\n    platform: str\n    content: str\n    media_url: Optional[str] = None\n    scheduled_at: datetime\n\n\nclass PostCreate(PostBase):\n    social_account_id: int\n\n\nclass PostUpdate(BaseModel):\n    content: Optional[str] = None\n    media_url: Optional[str] = None\n    scheduled_at: Optional[datetime] = None\n\n\nclass PostResponse(PostBase):\n    id: int\n    doctor_id: int\n    social_account_id: int\n    status: PostStatus\n    error_message: Optional[str] = None\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\nclass OAuthUrlResponse(BaseModel):\n    authorization_url: str","size_bytes":1166},"app/utils/__init__.py":{"content":"","size_bytes":0},"app/utils/jwt.py":{"content":"from datetime import datetime, timedelta, timezone\nfrom typing import Optional\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom app.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hash a password.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\ndef get_current_user_id(token: str) -> Optional[int]:\n    \"\"\"Extract user ID from JWT token.\"\"\"\n    payload = verify_token(token)\n    if payload is None:\n        return None\n    \n    user_id = payload.get(\"sub\")\n    if user_id is None:\n        return None\n    \n    try:\n        return int(user_id)\n    except (ValueError, TypeError):\n        return None","size_bytes":1659},"app/utils/otp.py":{"content":"import random\nimport string\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Optional\nfrom sqlalchemy.orm import Session\nfrom app.models.models import OTPVerification\nfrom app.config import settings\n\n\ndef generate_otp() -> str:\n    \"\"\"Generate a random OTP code.\"\"\"\n    return ''.join(random.choices(string.digits, k=settings.OTP_LENGTH))\n\n\ndef create_otp(db: Session, email: str, purpose: str) -> tuple[str, datetime]:\n    \"\"\"Create and store an OTP for email verification.\"\"\"\n    # Clean up any existing OTPs for this email and purpose\n    db.query(OTPVerification).filter(\n        OTPVerification.email == email,\n        OTPVerification.purpose == purpose\n    ).delete()\n    \n    # Generate new OTP\n    otp_code = generate_otp()\n    expires_at = datetime.now(timezone.utc) + timedelta(minutes=settings.OTP_EXPIRE_MINUTES)\n    \n    # Store OTP in database\n    otp_record = OTPVerification(\n        email=email,\n        otp_code=otp_code,\n        purpose=purpose,\n        expires_at=expires_at\n    )\n    db.add(otp_record)\n    db.commit()\n    \n    return otp_code, expires_at\n\n\ndef verify_otp(db: Session, email: str, otp_code: str, purpose: str) -> bool:\n    \"\"\"Verify an OTP code.\"\"\"\n    otp_record = db.query(OTPVerification).filter(\n        OTPVerification.email == email,\n        OTPVerification.otp_code == otp_code,\n        OTPVerification.purpose == purpose,\n        OTPVerification.is_used == False,\n        OTPVerification.expires_at > datetime.now(timezone.utc)\n    ).first()\n    \n    if not otp_record:\n        return False\n    \n    # Mark OTP as used\n    db.query(OTPVerification).filter(\n        OTPVerification.id == otp_record.id\n    ).update({\"is_used\": True})\n    db.commit()\n    \n    return True\n\n\ndef send_otp_email(email: str, otp_code: str, purpose: str) -> dict:\n    \"\"\"Simulate sending OTP via email (for demo purposes).\"\"\"\n    # In a real application, you would integrate with an email service\n    # For this demo, we'll just return a success message\n    return {\n        \"success\": True,\n        \"message\": f\"OTP {otp_code} sent to {email} for {purpose}\",\n        \"email\": email,\n        \"otp_code\": otp_code  # Remove this in production!\n    }","size_bytes":2192},"app/utils/profile.py":{"content":"from typing import Optional\nfrom app.models.models import Doctor\n\n\ndef calculate_profile_completeness(doctor: Doctor) -> int:\n    \"\"\"\n    Calculate the profile completeness percentage based on filled optional fields.\n    Required fields (full_name, email, hashed_password) are not counted as they're always present.\n    \"\"\"\n    # Define the optional fields that contribute to profile completeness\n    optional_fields = [\n        'phone_number',\n        'clinic_name',\n        'clinic_address', \n        'speciality_id',\n        'sub_speciality_id',\n        'years_of_experience',\n        'qualification',\n        'medical_institute',\n        'awards',\n        'medical_council_regd_no',\n        'profile_photo',\n        'professional_bio'\n    ]\n    \n    filled_fields = 0\n    total_fields = len(optional_fields)\n    \n    for field in optional_fields:\n        value = getattr(doctor, field, None)\n        \n        # Handle different field types appropriately\n        if field in ['speciality_id', 'sub_speciality_id', 'years_of_experience']:\n            # For numeric fields, consider filled if not None and > 0\n            if value is not None and value > 0:\n                filled_fields += 1\n        else:\n            # For string fields, consider filled if not None and not empty string\n            if value is not None and str(value).strip():\n                filled_fields += 1\n    \n    # Calculate percentage\n    completeness_percentage = int((filled_fields / total_fields) * 100) if total_fields > 0 else 100\n    \n    return completeness_percentage\n\n\ndef get_profile_completeness_tips(doctor: Doctor) -> list[str]:\n    \"\"\"\n    Get tips for improving profile completeness based on missing fields.\n    \"\"\"\n    tips = []\n    \n    phone_number = getattr(doctor, 'phone_number', None)\n    if not phone_number or not str(phone_number).strip():\n        tips.append(\"Add your phone number for WhatsApp contact\")\n    \n    clinic_name = getattr(doctor, 'clinic_name', None)\n    if not clinic_name or not str(clinic_name).strip():\n        tips.append(\"Add your clinic name to help patients find you\")\n    \n    clinic_address = getattr(doctor, 'clinic_address', None)\n    if not clinic_address or not str(clinic_address).strip():\n        tips.append(\"Add your clinic address for better visibility\")\n    \n    speciality_id = getattr(doctor, 'speciality_id', None)\n    if speciality_id is None or speciality_id <= 0:\n        tips.append(\"Select your medical speciality\")\n    \n    sub_speciality_id = getattr(doctor, 'sub_speciality_id', None)\n    if sub_speciality_id is None or sub_speciality_id <= 0:\n        tips.append(\"Choose your sub-speciality for more specific expertise\")\n    \n    years_of_experience = getattr(doctor, 'years_of_experience', None)\n    if years_of_experience is None or years_of_experience <= 0:\n        tips.append(\"Add your years of experience to build trust\")\n    \n    qualification = getattr(doctor, 'qualification', None)\n    if not qualification or not str(qualification).strip():\n        tips.append(\"Add your professional qualifications and degrees\")\n    \n    medical_institute = getattr(doctor, 'medical_institute', None)\n    if not medical_institute or not str(medical_institute).strip():\n        tips.append(\"Mention your medical institute/university\")\n    \n    awards = getattr(doctor, 'awards', None)\n    if not awards or not str(awards).strip():\n        tips.append(\"Add any awards or recognitions you've received\")\n    \n    medical_council_regd_no = getattr(doctor, 'medical_council_regd_no', None)\n    if not medical_council_regd_no or not str(medical_council_regd_no).strip():\n        tips.append(\"Add your medical council registration number\")\n    \n    profile_photo = getattr(doctor, 'profile_photo', None)\n    if not profile_photo or not str(profile_photo).strip():\n        tips.append(\"Upload a professional profile photo\")\n    \n    professional_bio = getattr(doctor, 'professional_bio', None)\n    if not professional_bio or not str(professional_bio).strip():\n        tips.append(\"Write a professional bio to introduce yourself\")\n    \n    return tips","size_bytes":4088},"app/utils/scheduler.py":{"content":"from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.triggers.interval import IntervalTrigger\nfrom sqlalchemy.orm import Session\nfrom datetime import datetime\nfrom app.db import SessionLocal\nfrom app.models.post import Post, PostStatus\nfrom app.utils.publishers.facebook_publisher import FacebookPublisher\nfrom app.utils.publishers.instagram_publisher import InstagramPublisher\nfrom app.utils.publishers.linkedin_publisher import LinkedInPublisher\nfrom app.utils.publishers.twitter_publisher import TwitterPublisher\nfrom app.utils.publishers.youtube_publisher import YouTubePublisher\nfrom app.utils.publishers.reddit_publisher import RedditPublisher\nfrom app.utils.publishers.quora_publisher import QuoraPublisher\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Publisher mapping\nPUBLISHERS = {\n    \"facebook\": FacebookPublisher(),\n    \"instagram\": InstagramPublisher(),\n    \"linkedin\": LinkedInPublisher(),\n    \"twitter\": TwitterPublisher(),\n    \"youtube\": YouTubePublisher(),\n    \"reddit\": RedditPublisher(),\n    \"quora\": QuoraPublisher(),\n}\n\n# Global scheduler instance\nscheduler = AsyncIOScheduler()\n\n\nasync def check_due_posts():\n    \"\"\"Check for posts that are due to be published\"\"\"\n    db: Session = SessionLocal()\n    try:\n        # Get all scheduled posts that are due\n        due_posts = db.query(Post).filter(\n            Post.status == PostStatus.SCHEDULED,\n            Post.scheduled_at <= datetime.now()\n        ).all()\n        \n        for post in due_posts:\n            await publish_post(post, db)\n            \n    except Exception as e:\n        logger.error(f\"Error checking due posts: {str(e)}\")\n    finally:\n        db.close()\n\n\nasync def publish_post(post: Post, db: Session):\n    \"\"\"Publish a single post using the appropriate publisher\"\"\"\n    try:\n        publisher = PUBLISHERS.get(post.platform)\n        if not publisher:\n            raise ValueError(f\"No publisher found for platform: {post.platform}\")\n        \n        logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on {post.platform}...\")\n        \n        # Call the publisher\n        await publisher.publish(post)\n        \n        # Update post status to published\n        post.status = PostStatus.PUBLISHED\n        post.error_message = None\n        \n        logger.info(f\"Successfully published post {post.id} on {post.platform}\")\n        \n    except Exception as e:\n        # Update post status to failed\n        post.status = PostStatus.FAILED\n        post.error_message = str(e)\n        \n        logger.error(f\"Failed to publish post {post.id} on {post.platform}: {str(e)}\")\n    \n    finally:\n        db.commit()\n\n\ndef start_scheduler():\n    \"\"\"Start the post scheduler\"\"\"\n    if not scheduler.running:\n        # Add job to check for due posts every minute\n        scheduler.add_job(\n            check_due_posts,\n            trigger=IntervalTrigger(minutes=1),\n            id=\"check_due_posts\",\n            name=\"Check for due posts\",\n            replace_existing=True\n        )\n        \n        scheduler.start()\n        logger.info(\"Post scheduler started\")\n\n\ndef stop_scheduler():\n    \"\"\"Stop the post scheduler\"\"\"\n    if scheduler.running:\n        scheduler.shutdown()\n        logger.info(\"Post scheduler stopped\")","size_bytes":3255},"app/utils/publishers/base_publisher.py":{"content":"from abc import ABC, abstractmethod\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass BasePublisher(ABC):\n    \"\"\"Base class for all social media publishers\"\"\"\n    \n    def __init__(self, platform_name: str):\n        self.platform_name = platform_name\n    \n    @abstractmethod\n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to the social media platform\n        \n        Args:\n            post: The Post object containing content and metadata\n            \n        Returns:\n            bool: True if successful, False otherwise\n            \n        Raises:\n            Exception: If publishing fails\n        \"\"\"\n        pass\n    \n    def log_success(self, post: Post):\n        \"\"\"Log successful publication\"\"\"\n        logger.info(f\"Published post {post.id} for doctor {post.doctor_id} on {self.platform_name}\")\n    \n    def log_error(self, post: Post, error: str):\n        \"\"\"Log publication error\"\"\"\n        logger.error(f\"Failed to publish post {post.id} on {self.platform_name}: {error}\")","size_bytes":1069},"app/utils/publishers/facebook_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass FacebookPublisher(BasePublisher):\n    \"\"\"Facebook post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"Facebook\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to Facebook\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would use the Facebook Graph API.\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with Facebook Graph API\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on Facebook...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1163},"app/utils/publishers/instagram_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass InstagramPublisher(BasePublisher):\n    \"\"\"Instagram post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"Instagram\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to Instagram\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would use the Instagram Basic Display API.\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with Instagram API\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on Instagram...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1172},"app/utils/publishers/linkedin_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass LinkedInPublisher(BasePublisher):\n    \"\"\"LinkedIn post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"LinkedIn\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to LinkedIn\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would use the LinkedIn API.\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with LinkedIn API\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on LinkedIn...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1151},"app/utils/publishers/quora_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass QuoraPublisher(BasePublisher):\n    \"\"\"Quora post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"Quora\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to Quora\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would integrate with Quora's API (if available).\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with Quora API\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on Quora...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1154},"app/utils/publishers/reddit_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass RedditPublisher(BasePublisher):\n    \"\"\"Reddit post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"Reddit\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to Reddit\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would use the Reddit API (PRAW).\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with Reddit API\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on Reddit...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1144},"app/utils/publishers/twitter_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass TwitterPublisher(BasePublisher):\n    \"\"\"Twitter post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"Twitter\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to Twitter\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would use the Twitter API v2.\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with Twitter API v2\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on Twitter...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1150},"app/utils/publishers/youtube_publisher.py":{"content":"from app.utils.publishers.base_publisher import BasePublisher\nfrom app.models.post import Post\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass YouTubePublisher(BasePublisher):\n    \"\"\"YouTube post publisher\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"YouTube\")\n    \n    async def publish(self, post: Post) -> bool:\n        \"\"\"\n        Publish a post to YouTube\n        \n        For now, this is a dummy implementation that just logs the action.\n        In production, this would use the YouTube Data API.\n        \"\"\"\n        try:\n            # Dummy implementation - in production, integrate with YouTube Data API\n            logger.info(f\"Publishing post {post.id} for doctor {post.doctor_id} on YouTube...\")\n            logger.info(f\"Content: {post.content[:100]}{'...' if len(post.content) > 100 else ''}\")\n            \n            if post.media_url:\n                logger.info(f\"Media URL: {post.media_url}\")\n            \n            # Simulate API call success\n            self.log_success(post)\n            return True\n            \n        except Exception as e:\n            self.log_error(post, str(e))\n            raise","size_bytes":1154}},"version":1}